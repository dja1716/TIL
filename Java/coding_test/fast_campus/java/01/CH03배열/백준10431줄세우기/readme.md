
출처: https://www.acmicpc.net/problem/10431
# 나의 풀이
* 문제의 방법을 그대로 차용
* 실제로 뒤로 가는 경우에 count를 증가시켜, 총 뒤로 간 경우를 계산했다.
* 실제 위치변환 (정렬)을 하였다
* 런타임: O(p * n^2)


# 다른 사람 풀이1
* 뒤로 가는 경우의 수는 각 인덱스 (i) 당, 그 수 보다 앞에 있지만, i번째 수보다 큰 경우에 count를 1증가시킨다
* 실제 위치변환 안함
* 런타임: O(p * n^2)
